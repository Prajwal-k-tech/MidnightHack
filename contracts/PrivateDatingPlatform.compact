pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// User status for account management
enum UserStatus {
    Active,
    Suspended,
    Banned
}

// Ledger state for the dating platform
export ledger total_users: Uint<64>;
export ledger nonce: Counter;

// Track users and their statuses
export ledger user_statuses: Map<Uint<32>, UserStatus>;

// Store commitments to user profile data (actual data kept off-chain)
export ledger profile_hashes: Map<Uint<32>, Bytes<32>>;

// Store commitments to user preferences (actual preferences kept off-chain)
export ledger preference_hashes: Map<Uint<32>, Bytes<32>>;

// Constructor to initialize the platform
constructor() {
    total_users = 0;
}

// ========== WITNESS FUNCTIONS (Private Inputs) ==========
// These functions provide private data without revealing it on-chain

// Witness for user's actual age (kept private)
witness getUserAge(user_id: Uint<32>): Uint<8>;

// Witness for user's location coordinates (kept private)
witness getUserLocation(user_id: Uint<32>): [Field, Field]; // [latitude, longitude]

// Witness for user's income (kept private)
witness getUserIncome(user_id: Uint<32>): Uint<64>;

// Witness for user's education level (kept private)
witness getUserEducation(user_id: Uint<32>): Uint<8>; // 0=HS, 1=Bachelor, 2=Master, 3=PhD

// Witness for government ID hash for sybil resistance
witness getIdHash(user_id: Uint<32>): Bytes<32>;

// Circuit to create a new user profile
export circuit create_profile(
    user_id: Uint<32>,
    profile_commitment: Bytes<32>
): [] {
    // Prevent duplicate user IDs (sybil resistance)
    assert(!user_statuses.member(disclose(user_id)), "User ID already exists");

    // Store user status and profile commitment
    user_statuses.insert(disclose(user_id), UserStatus.Active);
    profile_hashes.insert(disclose(user_id), disclose(profile_commitment));

    // Update total users count
    total_users = (total_users + 1) as Uint<64>;

    // Increment nonce for state tracking
    nonce.increment(1);
}

// Circuit to update user preferences
export circuit update_preferences(
    user_id: Uint<32>,
    preference_commitment: Bytes<32>
): [] {
    // Verify user exists and is active
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User is not active");

    // Update preference commitment
    preference_hashes.insert(disclose(user_id), disclose(preference_commitment));

    // Increment nonce for state tracking
    nonce.increment(1);
}

// Circuit to suspend a user account
export circuit suspend_user(user_id: Uint<32>): [] {
    // Verify user exists and is active
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User is not active");

    // Change user status to suspended
    user_statuses.insert(disclose(user_id), UserStatus.Suspended);

    // Increment nonce for state tracking
    nonce.increment(1);
}

// ========== PRIVACY-PRESERVING VERIFICATION CIRCUITS ==========

// Circuit to prove user's age is within a specified range without revealing exact age
export circuit prove_age_range(
    user_id: Uint<32>,
    min_age: Uint<8>,
    max_age: Uint<8>
): Boolean {
    // Ensure user exists and is active
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    // Get private age without revealing it
    const user_age = getUserAge(user_id);
    
    // Prove age is in range using ZK constraints
    const in_range = (user_age >= min_age) && (user_age <= max_age);
    
    return in_range;
}

// Circuit to prove user is within specified distance without revealing exact location
export circuit prove_location_proximity(
    user_id: Uint<32>,
    target_lat: Field,
    target_lng: Field,
    max_distance_sq: Field // distance squared to avoid division
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const [user_lat, user_lng] = getUserLocation(user_id);
    
    // Calculate distance squared (avoids division which isn't supported yet)
    const lat_diff = user_lat - target_lat;
    const lng_diff = user_lng - target_lng;
    const distance_sq = lat_diff * lat_diff + lng_diff * lng_diff;
    
    return distance_sq <= max_distance_sq;
}

// Circuit to prove income is within bracket without revealing exact amount
export circuit prove_income_bracket(
    user_id: Uint<32>,
    min_income: Uint<64>,
    max_income: Uint<64>
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const user_income = getUserIncome(user_id);
    return (user_income >= min_income) && (user_income <= max_income);
}

// Circuit to prove education level meets minimum requirement
export circuit prove_education_level(
    user_id: Uint<32>,
    min_education: Uint<8>
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const user_education = getUserEducation(user_id);
    return user_education >= min_education;
}

// Circuit for sybil resistance - verify unique government ID without storing it
export circuit verify_unique_identity(
    user_id: Uint<32>,
    id_commitment: Bytes<32>
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    
    const user_id_hash = getIdHash(user_id);
    
    // This would need additional logic to check against existing ID hashes
    // For demo purposes, we just verify the commitment matches
    return user_id_hash == id_commitment;
}

// ========== COMPATIBILITY MATCHING CIRCUITS ==========

// Circuit to compute compatibility score between two users
export circuit compute_compatibility(
    user1_id: Uint<32>,
    user2_id: Uint<32>,
    age_weight: Field,
    location_weight: Field,
    income_weight: Field,
    education_weight: Field
): Field {
    // Both users must exist and be active
    assert(user_statuses.member(disclose(user1_id)), "User 1 does not exist");
    assert(user_statuses.member(disclose(user2_id)), "User 2 does not exist");
    assert(user_statuses.lookup(disclose(user1_id)) == UserStatus.Active, "User 1 not active");
    assert(user_statuses.lookup(disclose(user2_id)) == UserStatus.Active, "User 2 not active");
    
    // Get private data for both users
    const age1 = getUserAge(user1_id);
    const age2 = getUserAge(user2_id);
    const [lat1, lng1] = getUserLocation(user1_id);
    const [lat2, lng2] = getUserLocation(user2_id);
    const income1 = getUserIncome(user1_id);
    const income2 = getUserIncome(user2_id);
    const edu1 = getUserEducation(user1_id);
    const edu2 = getUserEducation(user2_id);
    
    // Calculate compatibility factors (simplified scoring)
    const age1_field = age1 as Field;
    const age2_field = age2 as Field;
    const age_diff_raw = age1_field - age2_field;
    const age_diff = abs_field(age_diff_raw);
    const age_penalty = age_diff * (5 as Field);
    const age_score = max_field((100 as Field) - age_penalty, 0 as Field);
    
    const lat_diff = lat1 - lat2;
    const lng_diff = lng1 - lng2;
    const location_diff_sq = lat_diff * lat_diff + lng_diff * lng_diff;
    const location_score = max_field((100 as Field) - location_diff_sq, 0 as Field);
    
    const income1_field = income1 as Field;
    const income2_field = income2 as Field;
    const income_diff_raw = income1_field - income2_field;
    const income_diff = abs_field(income_diff_raw);
    const income_score = max_field((100 as Field) - income_diff, 0 as Field);
    
    const edu1_field = edu1 as Field;
    const edu2_field = edu2 as Field;
    const edu_diff_raw = edu1_field - edu2_field;
    const edu_diff = abs_field(edu_diff_raw);
    const edu_penalty = edu_diff * (10 as Field);
    const edu_score = max_field((100 as Field) - edu_penalty, 0 as Field);
    
    // Weighted compatibility score (simplified without division)
    const weighted_age = age_score * age_weight;
    const weighted_location = location_score * location_weight;
    const weighted_income = income_score * income_weight;
    const weighted_edu = edu_score * education_weight;
    const total_score = weighted_age + weighted_location + weighted_income + weighted_edu;
    
    return total_score;
}

// Helper function to calculate absolute value for Field type
pure circuit abs_field(x: Field): Field {
    if (x >= (0 as Field)) {
        return x;
    } else {
        const zero = 0 as Field;
        return zero - x;
    }
}

// Helper function to calculate maximum of two Field values
pure circuit max_field(a: Field, b: Field): Field {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}
