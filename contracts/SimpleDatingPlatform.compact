pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// User status for account management
enum UserStatus {
    Active,
    Suspended,
    Banned
}

// Ledger state for the dating platform
export ledger total_users: Uint<64>;
export ledger nonce: Counter;

// Track users and their statuses
export ledger user_statuses: Map<Uint<32>, UserStatus>;

// Store commitments to user profile data (actual data kept off-chain)
export ledger profile_hashes: Map<Uint<32>, Bytes<32>>;

// Store verified compatibility matches
export ledger compatibility_matches: Map<[Uint<32>, Uint<32>], Boolean>;

// Constructor to initialize the platform
constructor() {
    total_users = 0;
}

// ========== WITNESS FUNCTIONS (Private Inputs) ==========
// These functions provide private data without revealing it on-chain

// Witness for user's actual age (kept private)
witness getUserAge(user_id: Uint<32>): Uint<8>;

// Witness for user's location coordinates (kept private)  
witness getUserLocation(user_id: Uint<32>): [Uint<32>, Uint<32>]; // [lat_int, lng_int] 

// Witness for user's income (kept private)
witness getUserIncome(user_id: Uint<32>): Uint<64>;

// Witness for government ID hash for sybil resistance
witness getIdHash(user_id: Uint<32>): Bytes<32>;

// ========== CORE PLATFORM CIRCUITS ==========

// Circuit to create a new user profile with identity verification
export circuit create_verified_profile(
    user_id: Uint<32>,
    profile_commitment: Bytes<32>,
    id_commitment: Bytes<32>
): Boolean {
    // Prevent duplicate user IDs (sybil resistance)
    assert(!user_statuses.member(disclose(user_id)), "User ID already exists");

    // Verify unique government ID without storing it
    const user_id_hash = getIdHash(user_id);
    assert(user_id_hash == id_commitment, "ID verification failed");

    // Store user status and profile commitment
    user_statuses.insert(disclose(user_id), UserStatus.Active);
    profile_hashes.insert(disclose(user_id), disclose(profile_commitment));

    // Update total users count
    total_users = (total_users + 1) as Uint<64>;
    nonce.increment(1);

    return true;
}

// ========== PRIVACY-PRESERVING VERIFICATION CIRCUITS ==========

// Circuit to prove user's age is within a specified range without revealing exact age
export circuit prove_age_range(
    user_id: Uint<32>,
    min_age: Uint<8>,
    max_age: Uint<8>
): Boolean {
    // Ensure user exists and is active
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    // Get private age without revealing it
    const user_age = getUserAge(user_id);
    
    // Prove age is in range using ZK constraints
    const min_check = user_age >= min_age;
    const max_check = user_age <= max_age;
    const in_range = min_check && max_check;
    
    return in_range;
}

// Circuit to prove user is within specified distance (simplified)
export circuit prove_location_proximity(
    user_id: Uint<32>,
    target_lat: Uint<32>,
    target_lng: Uint<32>,
    max_distance: Uint<32>
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const [user_lat, user_lng] = getUserLocation(user_id);
    
    // Simplified distance check (Manhattan distance for demo)
    const lat_diff = (user_lat >= target_lat) ? (user_lat - target_lat) : (target_lat - user_lat);
    const lng_diff = (user_lng >= target_lng) ? (user_lng - target_lng) : (target_lng - user_lng);
    const manhattan_distance = lat_diff + lng_diff;
    
    return manhattan_distance <= max_distance;
}

// Circuit to prove income is within bracket without revealing exact amount
export circuit prove_income_bracket(
    user_id: Uint<32>,
    min_income: Uint<64>,
    max_income: Uint<64>
): Boolean {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const user_income = getUserIncome(user_id);
    const min_check = user_income >= min_income;
    const max_check = user_income <= max_income;
    
    return min_check && max_check;
}

// ========== COMPATIBILITY MATCHING CIRCUITS ==========

// Circuit to verify mutual compatibility between two users
export circuit verify_mutual_compatibility(
    user1_id: Uint<32>,
    user2_id: Uint<32>,
    age_range_1: [Uint<8>, Uint<8>], // [min_age, max_age] for user1's preferences
    age_range_2: [Uint<8>, Uint<8>], // [min_age, max_age] for user2's preferences
    max_distance: Uint<32>
): Boolean {
    // Both users must exist and be active
    assert(user_statuses.member(disclose(user1_id)), "User 1 does not exist");
    assert(user_statuses.member(disclose(user2_id)), "User 2 does not exist");
    assert(user_statuses.lookup(disclose(user1_id)) == UserStatus.Active, "User 1 not active");
    assert(user_statuses.lookup(disclose(user2_id)) == UserStatus.Active, "User 2 not active");
    
    // Get private data for both users
    const age1 = getUserAge(user1_id);
    const age2 = getUserAge(user2_id);
    const [lat1, lng1] = getUserLocation(user1_id);
    const [lat2, lng2] = getUserLocation(user2_id);
    
    // Check if user1 meets user2's age preferences
    const user1_meets_age = (age1 >= age_range_2[0]) && (age1 <= age_range_2[1]);
    
    // Check if user2 meets user1's age preferences  
    const user2_meets_age = (age2 >= age_range_1[0]) && (age2 <= age_range_1[1]);
    
    // Check proximity (simplified Manhattan distance)
    const lat_diff = (lat1 >= lat2) ? (lat1 - lat2) : (lat2 - lat1);
    const lng_diff = (lng1 >= lng2) ? (lng1 - lng2) : (lng2 - lng1);
    const distance = lat_diff + lng_diff;
    const proximity_check = distance <= max_distance;
    
    // All conditions must be met for compatibility
    const compatible = user1_meets_age && user2_meets_age && proximity_check;
    
    // Store the match if compatible
    if (compatible) {
        compatibility_matches.insert(disclose([user1_id, user2_id]), true);
        compatibility_matches.insert(disclose([user2_id, user1_id]), true);
    }
    
    return compatible;
}

// Circuit to check if two users are already matched
export circuit check_existing_match(
    user1_id: Uint<32>,
    user2_id: Uint<32>
): Boolean {
    assert(user_statuses.member(disclose(user1_id)), "User 1 does not exist");
    assert(user_statuses.member(disclose(user2_id)), "User 2 does not exist");
    
    return compatibility_matches.member(disclose([user1_id, user2_id]));
}