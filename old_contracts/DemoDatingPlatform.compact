pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// User status for account management
enum UserStatus {
    Active,
    Suspended,
    Banned
}

// Verification result for selective disclosure
enum VerificationResult {
    Verified,
    Failed
}

// Ledger state for the dating platform
export ledger total_users: Uint<64>;
export ledger nonce: Counter;

// Track users and their statuses
export ledger user_statuses: Map<Uint<32>, UserStatus>;

// Store age verification results (disclosed)
export ledger age_verifications: Map<Uint<32>, VerificationResult>;

// Store location verification results (disclosed)
export ledger location_verifications: Map<Uint<32>, VerificationResult>;

// Store income verification results (disclosed)
export ledger income_verifications: Map<Uint<32>, VerificationResult>;

// Store verified matches
export ledger verified_matches: Map<[Uint<32>, Uint<32>], Boolean>;

// Constructor to initialize the platform
constructor() {
    total_users = 0;
}

// ========== WITNESS FUNCTIONS (Private Inputs) ==========
// These provide private data without revealing exact values

witness getUserAge(user_id: Uint<32>): Uint<8>;
witness getUserLocation(user_id: Uint<32>): [Uint<32>, Uint<32>];
witness getUserIncome(user_id: Uint<32>): Uint<64>;
witness getIdHash(user_id: Uint<32>): Bytes<32>;

// ========== CORE PLATFORM CIRCUITS ==========

// Circuit to create a verified user profile
export circuit create_verified_profile(
    user_id: Uint<32>,
    profile_commitment: Bytes<32>
): Boolean {
    // Prevent duplicate user IDs (sybil resistance)
    assert(!user_statuses.member(disclose(user_id)), "User ID already exists");

    // Store user status 
    user_statuses.insert(disclose(user_id), UserStatus.Active);

    // Update total users count
    total_users = (total_users + 1) as Uint<64>;
    nonce.increment(1);

    return true;
}

// ========== PRIVACY-PRESERVING VERIFICATION CIRCUITS ==========

// Circuit to verify age range and disclose verification result (not exact age)
export circuit verify_and_disclose_age_range(
    user_id: Uint<32>,
    min_age: Uint<8>,
    max_age: Uint<8>
): [] {
    // Ensure user exists and is active
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    // Get private age (not disclosed)
    const user_age = getUserAge(user_id);
    
    // Verify age is in range
    const min_check = user_age >= min_age;
    const max_check = user_age <= max_age;
    const in_range = min_check && max_check;
    
    // Disclose only the verification result (not the actual age)
    const result = in_range ? VerificationResult.Verified : VerificationResult.Failed;
    age_verifications.insert(disclose(user_id), disclose(result));
    
    nonce.increment(1);
}

// Circuit to verify location proximity and disclose verification result
export circuit verify_and_disclose_location_proximity(
    user_id: Uint<32>,
    target_lat: Uint<32>,
    target_lng: Uint<32>,
    max_distance: Uint<32>
): [] {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const [user_lat, user_lng] = getUserLocation(user_id);
    
    // Simplified distance check (Manhattan distance for demo)
    const lat_diff = (user_lat >= target_lat) ? (user_lat - target_lat) : (target_lat - user_lat);
    const lng_diff = (user_lng >= target_lng) ? (user_lng - target_lng) : (target_lng - user_lng);
    const manhattan_distance = lat_diff + lng_diff;
    const within_range = manhattan_distance <= max_distance;
    
    // Disclose only the verification result (not exact location)
    const result = within_range ? VerificationResult.Verified : VerificationResult.Failed;
    location_verifications.insert(disclose(user_id), disclose(result));
    
    nonce.increment(1);
}

// Circuit to verify income bracket and disclose verification result
export circuit verify_and_disclose_income_bracket(
    user_id: Uint<32>,
    min_income: Uint<64>,
    max_income: Uint<64>
): [] {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    assert(user_statuses.lookup(disclose(user_id)) == UserStatus.Active, "User not active");
    
    const user_income = getUserIncome(user_id);
    const min_check = user_income >= min_income;
    const max_check = user_income <= max_income;
    const in_range = min_check && max_check;
    
    // Disclose only the verification result (not actual income)
    const result = in_range ? VerificationResult.Verified : VerificationResult.Failed;
    income_verifications.insert(disclose(user_id), disclose(result));
    
    nonce.increment(1);
}

// ========== MATCHING CIRCUITS ==========

// Circuit to create a verified match based on disclosed verification results
export circuit create_verified_match(
    user1_id: Uint<32>,
    user2_id: Uint<32>
): Boolean {
    // Both users must exist and be active
    assert(user_statuses.member(disclose(user1_id)), "User 1 does not exist");
    assert(user_statuses.member(disclose(user2_id)), "User 2 does not exist");
    assert(user_statuses.lookup(disclose(user1_id)) == UserStatus.Active, "User 1 not active");
    assert(user_statuses.lookup(disclose(user2_id)) == UserStatus.Active, "User 2 not active");
    
    // Check if both users have verified their basic attributes
    const user1_age_verified = age_verifications.member(disclose(user1_id)) && 
                              age_verifications.lookup(disclose(user1_id)) == VerificationResult.Verified;
    const user2_age_verified = age_verifications.member(disclose(user2_id)) && 
                              age_verifications.lookup(disclose(user2_id)) == VerificationResult.Verified;
    
    const user1_location_verified = location_verifications.member(disclose(user1_id)) && 
                                   location_verifications.lookup(disclose(user1_id)) == VerificationResult.Verified;
    const user2_location_verified = location_verifications.member(disclose(user2_id)) && 
                                   location_verifications.lookup(disclose(user2_id)) == VerificationResult.Verified;
    
    // Both users must have verified attributes for a match
    const compatible = user1_age_verified && user2_age_verified && 
                      user1_location_verified && user2_location_verified;
    
    // Store the match if compatible
    if (compatible) {
        verified_matches.insert(disclose([user1_id, user2_id]), disclose(true));
        verified_matches.insert(disclose([user2_id, user1_id]), disclose(true));
        nonce.increment(1);
    }
    
    return compatible;
}

// Circuit to check if two users have a verified match
export circuit check_verified_match(
    user1_id: Uint<32>,
    user2_id: Uint<32>
): Boolean {
    assert(user_statuses.member(disclose(user1_id)), "User 1 does not exist");
    assert(user_statuses.member(disclose(user2_id)), "User 2 does not exist");
    
    return verified_matches.member(disclose([user1_id, user2_id]));
}

// Circuit to get verification status for a user
export circuit get_verification_status(user_id: Uint<32>): [Boolean, Boolean, Boolean] {
    assert(user_statuses.member(disclose(user_id)), "User does not exist");
    
    const age_verified = age_verifications.member(disclose(user_id)) && 
                        age_verifications.lookup(disclose(user_id)) == VerificationResult.Verified;
    const location_verified = location_verifications.member(disclose(user_id)) && 
                             location_verifications.lookup(disclose(user_id)) == VerificationResult.Verified;
    const income_verified = income_verifications.member(disclose(user_id)) && 
                           income_verifications.lookup(disclose(user_id)) == VerificationResult.Verified;
    
    return [age_verified, location_verified, income_verified];
}