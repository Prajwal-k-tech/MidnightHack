"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_services_faceVerificationService_ts"],{

/***/ "(app-pages-browser)/./src/lib/services/faceVerificationService.ts":
/*!*****************************************************!*\
  !*** ./src/lib/services/faceVerificationService.ts ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FaceVerificationService: function() { return /* binding */ FaceVerificationService; },\n/* harmony export */   faceVerificationService: function() { return /* binding */ faceVerificationService; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ FaceVerificationService,faceVerificationService auto */ class FaceVerificationService {\n    /**\n   * Start camera for face capture\n   */ async startCamera(videoElement) {\n        try {\n            if (typeof navigator === \"undefined\" || !navigator.mediaDevices) {\n                throw new Error(\"Camera access not available in this environment\");\n            }\n            console.log(\"\\uD83D\\uDCF8 Starting camera for face verification...\");\n            this.videoStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 640\n                    },\n                    height: {\n                        ideal: 480\n                    },\n                    facingMode: \"user\"\n                }\n            });\n            videoElement.srcObject = this.videoStream;\n            console.log(\"✅ Camera started successfully\");\n        } catch (error) {\n            console.error(\"❌ Camera access denied:\", error);\n            throw new Error(\"Camera access is required for face verification\");\n        }\n    }\n    /**\n   * Stop camera stream\n   */ stopCamera() {\n        if (this.videoStream) {\n            this.videoStream.getTracks().forEach((track)=>track.stop());\n            this.videoStream = null;\n            console.log(\"\\uD83D\\uDCF8 Camera stopped\");\n        }\n    }\n    /**\n   * Capture face image from video stream\n   */ captureFace(videoElement) {\n        if (!this.canvas || !this.context) {\n            console.error(\"Canvas not initialized - service must be used in browser\");\n            return null;\n        }\n        this.canvas.width = videoElement.videoWidth;\n        this.canvas.height = videoElement.videoHeight;\n        // Draw current video frame to canvas\n        this.context.drawImage(videoElement, 0, 0);\n        // Get image data\n        const imageDataUrl = this.canvas.toDataURL(\"image/jpeg\", 0.8);\n        console.log(\"\\uD83D\\uDCF8 Face captured\");\n        return {\n            imageDataUrl,\n            confidence: 0.95,\n            timestamp: Date.now()\n        };\n    }\n    /**\n   * 🔒 GENERATE BIOMETRIC HASH (Privacy-Preserving)\n   * Creates a cryptographic commitment to facial features\n   * without storing the actual biometric data\n   */ async generateBiometricHash(faceData) {\n        console.log(\"\\uD83D\\uDD10 Generating biometric hash...\");\n        // Simulate advanced biometric feature extraction\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n        // In production, this would use:\n        // 1. Face detection (MediaPipe, OpenCV)\n        // 2. Feature extraction (embeddings)\n        // 3. Cryptographic hashing of features\n        // For demo: create hash from image data\n        const buffer = new TextEncoder().encode(faceData.imageDataUrl);\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const hashHex = hashArray.map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n        console.log(\"✅ Biometric hash generated:\", hashHex.substring(0, 16) + \"...\");\n        return hashHex;\n    }\n    /**\n   * 🔒 VERIFY FACE MATCH (Zero-Knowledge)\n   * Proves two faces match without revealing biometric data\n   */ async verifyFaceMatch(currentFace, storedBiometricHash) {\n        console.log(\"\\uD83D\\uDD10 Starting ZK biometric verification...\");\n        // Generate hash for current face\n        const currentHash = await this.generateBiometricHash(currentFace);\n        // Simulate ZK proof generation\n        console.log(\"\\uD83E\\uDDEE Generating zero-knowledge proof...\");\n        await new Promise((resolve)=>setTimeout(resolve, 1500));\n        // In production, this would:\n        // 1. Compare biometric features in ZK circuit\n        // 2. Generate proof of match/no-match\n        // 3. Not reveal the actual biometric data\n        // For demo: check hash similarity (simulating feature matching)\n        const similarity = this.calculateHashSimilarity(currentHash, storedBiometricHash);\n        const isVerified = similarity > 0.85; // 85% similarity threshold\n        const proof = {\n            isVerified,\n            confidenceScore: similarity,\n            biometricHash: currentHash,\n            proofGenerated: true\n        };\n        console.log(\"✅ Biometric verification complete:\", {\n            verified: isVerified,\n            confidence: \"\".concat(Math.round(similarity * 100), \"%\")\n        });\n        return proof;\n    }\n    /**\n   * Calculate similarity between two biometric hashes\n   * (In production, this would be in a ZK circuit)\n   */ calculateHashSimilarity(hash1, hash2) {\n        if (hash1 === hash2) return 1.0;\n        // Simple similarity based on hash prefix matching\n        let matches = 0;\n        const compareLength = Math.min(hash1.length, hash2.length, 16);\n        for(let i = 0; i < compareLength; i++){\n            if (hash1[i] === hash2[i]) matches++;\n        }\n        return matches / compareLength;\n    }\n    /**\n   * 🔐 ANONYMOUS FACE VERIFICATION\n   * Verify face authenticity without identity linkage\n   */ async verifyFaceAuthenticity(faceData) {\n        console.log(\"\\uD83D\\uDD0D Verifying face authenticity...\");\n        // Simulate liveness detection and anti-spoofing\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // In production, this would check:\n        // - Face liveness (eye blinks, head movement)\n        // - Anti-spoofing (3D face detection)\n        // - Image quality assessment\n        const result = {\n            isRealPerson: faceData.confidence > 0.8,\n            isLive: faceData.confidence > 0.9,\n            qualityScore: faceData.confidence\n        };\n        console.log(\"✅ Authenticity verification:\", result);\n        return result;\n    }\n    constructor(){\n        this.canvas = null;\n        this.context = null;\n        this.stream = null;\n        this.videoStream = null;\n        // Only initialize in browser environment\n        if ( true && typeof document !== \"undefined\") {\n            this.canvas = document.createElement(\"canvas\");\n            this.context = this.canvas.getContext(\"2d\");\n        }\n    }\n}\nconst faceVerificationService = new FaceVerificationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvZmFjZVZlcmlmaWNhdGlvblNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7cUdBc0JPLE1BQU1BO0lBY1g7O0dBRUMsR0FDRCxNQUFNQyxZQUFZQyxZQUE4QixFQUFpQjtRQUMvRCxJQUFJO1lBQ0YsSUFBSSxPQUFPQyxjQUFjLGVBQWUsQ0FBQ0EsVUFBVUMsWUFBWSxFQUFFO2dCQUMvRCxNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQUMsUUFBUUMsR0FBRyxDQUFDO1lBRVosSUFBSSxDQUFDQyxXQUFXLEdBQUcsTUFBTUwsVUFBVUMsWUFBWSxDQUFDSyxZQUFZLENBQUM7Z0JBQzNEQyxPQUFPO29CQUNMQyxPQUFPO3dCQUFFQyxPQUFPO29CQUFJO29CQUNwQkMsUUFBUTt3QkFBRUQsT0FBTztvQkFBSTtvQkFDckJFLFlBQVk7Z0JBQ2Q7WUFDRjtZQUVBWixhQUFhYSxTQUFTLEdBQUcsSUFBSSxDQUFDUCxXQUFXO1lBQ3pDRixRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9TLE9BQU87WUFDZFYsUUFBUVUsS0FBSyxDQUFDLDJCQUEyQkE7WUFDekMsTUFBTSxJQUFJWCxNQUFNO1FBQ2xCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEWSxhQUFtQjtRQUNqQixJQUFJLElBQUksQ0FBQ1QsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQ0EsV0FBVyxDQUFDVSxTQUFTLEdBQUdDLE9BQU8sQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUMsSUFBSTtZQUN4RCxJQUFJLENBQUNiLFdBQVcsR0FBRztZQUNuQkYsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtJQUVBOztHQUVDLEdBQ0RlLFlBQVlwQixZQUE4QixFQUFtQjtRQUMzRCxJQUFJLENBQUMsSUFBSSxDQUFDcUIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxPQUFPLEVBQUU7WUFDakNsQixRQUFRVSxLQUFLLENBQUM7WUFDZCxPQUFPO1FBQ1Q7UUFF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UUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztRQUVqRCxtQ0FBbUM7UUFDbkMsOENBQThDO1FBQzlDLHNDQUFzQztRQUN0Qyw2QkFBNkI7UUFFN0IsTUFBTTBDLFNBQVM7WUFDYkMsY0FBYzdDLFNBQVNMLFVBQVUsR0FBRztZQUNwQ21ELFFBQVE5QyxTQUFTTCxVQUFVLEdBQUc7WUFDOUJvRCxjQUFjL0MsU0FBU0wsVUFBVTtRQUNuQztRQUVBeEIsUUFBUUMsR0FBRyxDQUFDLGdDQUFnQ3dFO1FBQzVDLE9BQU9BO0lBQ1Q7SUF6TEFJLGFBQWM7YUFMTjVELFNBQW1DO2FBQ25DQyxVQUEyQzthQUMzQzRELFNBQTZCO2FBQzdCNUUsY0FBa0M7UUFHeEMseUNBQXlDO1FBQ3pDLElBQUksS0FBa0IsSUFBZSxPQUFPNkUsYUFBYSxhQUFhO1lBQ3BFLElBQUksQ0FBQzlELE1BQU0sR0FBRzhELFNBQVNDLGFBQWEsQ0FBQztZQUNyQyxJQUFJLENBQUM5RCxPQUFPLEdBQUcsSUFBSSxDQUFDRCxNQUFNLENBQUNnRSxVQUFVLENBQUM7UUFDeEM7SUFDRjtBQW9MRjtBQUVPLE1BQU1DLDBCQUEwQixJQUFJeEYsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc2VydmljZXMvZmFjZVZlcmlmaWNhdGlvblNlcnZpY2UudHM/NTE0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLyoqXG4gKiDwn5SQIEZBQ0UgVkVSSUZJQ0FUSU9OIFNFUlZJQ0VcbiAqIFByaXZhY3ktcHJlc2VydmluZyBiaW9tZXRyaWMgdmVyaWZpY2F0aW9uIHVzaW5nIHplcm8ta25vd2xlZGdlIHByb29mc1xuICogSW5zcGlyZWQgYnkgZmFjZS1yZWNvZ25pdGlvbi1taWRuaWdodCByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEZhY2VEYXRhIHtcbiAgaW1hZ2VEYXRhVXJsOiBzdHJpbmc7XG4gIGZhY2VIYXNoPzogc3RyaW5nO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpb21ldHJpY1Byb29mIHtcbiAgaXNWZXJpZmllZDogYm9vbGVhbjtcbiAgY29uZmlkZW5jZVNjb3JlOiBudW1iZXI7XG4gIGJpb21ldHJpY0hhc2g6IHN0cmluZztcbiAgcHJvb2ZHZW5lcmF0ZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBGYWNlVmVyaWZpY2F0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB2aWRlb1N0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBPbmx5IGluaXRpYWxpemUgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgY2FtZXJhIGZvciBmYWNlIGNhcHR1cmVcbiAgICovXG4gIGFzeW5jIHN0YXJ0Q2FtZXJhKHZpZGVvRWxlbWVudDogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW1lcmEgYWNjZXNzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+TuCBTdGFydGluZyBjYW1lcmEgZm9yIGZhY2UgdmVyaWZpY2F0aW9uLi4uJyk7XG4gICAgICBcbiAgICAgIHRoaXMudmlkZW9TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgd2lkdGg6IHsgaWRlYWw6IDY0MCB9LFxuICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogNDgwIH0sXG4gICAgICAgICAgZmFjaW5nTW9kZTogJ3VzZXInXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gdGhpcy52aWRlb1N0cmVhbTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ2FtZXJhIHN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBDYW1lcmEgYWNjZXNzIGRlbmllZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbWVyYSBhY2Nlc3MgaXMgcmVxdWlyZWQgZm9yIGZhY2UgdmVyaWZpY2F0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgY2FtZXJhIHN0cmVhbVxuICAgKi9cbiAgc3RvcENhbWVyYSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy52aWRlb1N0cmVhbSkge1xuICAgICAgdGhpcy52aWRlb1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICB0aGlzLnZpZGVvU3RyZWFtID0gbnVsbDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5O4IENhbWVyYSBzdG9wcGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgZmFjZSBpbWFnZSBmcm9tIHZpZGVvIHN0cmVhbVxuICAgKi9cbiAgY2FwdHVyZUZhY2UodmlkZW9FbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50KTogRmFjZURhdGEgfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNvbnRleHQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbnZhcyBub3QgaW5pdGlhbGl6ZWQgLSBzZXJ2aWNlIG11c3QgYmUgdXNlZCBpbiBicm93c2VyJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgXG4gICAgLy8gRHJhdyBjdXJyZW50IHZpZGVvIGZyYW1lIHRvIGNhbnZhc1xuICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwKTtcbiAgICBcbiAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgIGNvbnN0IGltYWdlRGF0YVVybCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk7ggRmFjZSBjYXB0dXJlZCcpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpbWFnZURhdGFVcmwsXG4gICAgICBjb25maWRlbmNlOiAwLjk1LCAvLyBTaW11bGF0ZWQgY29uZmlkZW5jZVxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiDwn5SSIEdFTkVSQVRFIEJJT01FVFJJQyBIQVNIIChQcml2YWN5LVByZXNlcnZpbmcpXG4gICAqIENyZWF0ZXMgYSBjcnlwdG9ncmFwaGljIGNvbW1pdG1lbnQgdG8gZmFjaWFsIGZlYXR1cmVzXG4gICAqIHdpdGhvdXQgc3RvcmluZyB0aGUgYWN0dWFsIGJpb21ldHJpYyBkYXRhXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUJpb21ldHJpY0hhc2goZmFjZURhdGE6IEZhY2VEYXRhKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UkCBHZW5lcmF0aW5nIGJpb21ldHJpYyBoYXNoLi4uJyk7XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgYWR2YW5jZWQgYmlvbWV0cmljIGZlYXR1cmUgZXh0cmFjdGlvblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG4gICAgXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCB1c2U6XG4gICAgLy8gMS4gRmFjZSBkZXRlY3Rpb24gKE1lZGlhUGlwZSwgT3BlbkNWKVxuICAgIC8vIDIuIEZlYXR1cmUgZXh0cmFjdGlvbiAoZW1iZWRkaW5ncylcbiAgICAvLyAzLiBDcnlwdG9ncmFwaGljIGhhc2hpbmcgb2YgZmVhdHVyZXNcbiAgICBcbiAgICAvLyBGb3IgZGVtbzogY3JlYXRlIGhhc2ggZnJvbSBpbWFnZSBkYXRhXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGZhY2VEYXRhLmltYWdlRGF0YVVybCk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmZmVyKTtcbiAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTtcbiAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgQmlvbWV0cmljIGhhc2ggZ2VuZXJhdGVkOicsIGhhc2hIZXguc3Vic3RyaW5nKDAsIDE2KSArICcuLi4nKTtcbiAgICByZXR1cm4gaGFzaEhleDtcbiAgfVxuXG4gIC8qKlxuICAgKiDwn5SSIFZFUklGWSBGQUNFIE1BVENIIChaZXJvLUtub3dsZWRnZSlcbiAgICogUHJvdmVzIHR3byBmYWNlcyBtYXRjaCB3aXRob3V0IHJldmVhbGluZyBiaW9tZXRyaWMgZGF0YVxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5RmFjZU1hdGNoKFxuICAgIGN1cnJlbnRGYWNlOiBGYWNlRGF0YSxcbiAgICBzdG9yZWRCaW9tZXRyaWNIYXNoOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxCaW9tZXRyaWNQcm9vZj4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SQIFN0YXJ0aW5nIFpLIGJpb21ldHJpYyB2ZXJpZmljYXRpb24uLi4nKTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBoYXNoIGZvciBjdXJyZW50IGZhY2VcbiAgICBjb25zdCBjdXJyZW50SGFzaCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVCaW9tZXRyaWNIYXNoKGN1cnJlbnRGYWNlKTtcbiAgICBcbiAgICAvLyBTaW11bGF0ZSBaSyBwcm9vZiBnZW5lcmF0aW9uXG4gICAgY29uc29sZS5sb2coJ/Cfp64gR2VuZXJhdGluZyB6ZXJvLWtub3dsZWRnZSBwcm9vZi4uLicpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTAwKSk7XG4gICAgXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZDpcbiAgICAvLyAxLiBDb21wYXJlIGJpb21ldHJpYyBmZWF0dXJlcyBpbiBaSyBjaXJjdWl0XG4gICAgLy8gMi4gR2VuZXJhdGUgcHJvb2Ygb2YgbWF0Y2gvbm8tbWF0Y2hcbiAgICAvLyAzLiBOb3QgcmV2ZWFsIHRoZSBhY3R1YWwgYmlvbWV0cmljIGRhdGFcbiAgICBcbiAgICAvLyBGb3IgZGVtbzogY2hlY2sgaGFzaCBzaW1pbGFyaXR5IChzaW11bGF0aW5nIGZlYXR1cmUgbWF0Y2hpbmcpXG4gICAgY29uc3Qgc2ltaWxhcml0eSA9IHRoaXMuY2FsY3VsYXRlSGFzaFNpbWlsYXJpdHkoY3VycmVudEhhc2gsIHN0b3JlZEJpb21ldHJpY0hhc2gpO1xuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBzaW1pbGFyaXR5ID4gMC44NTsgLy8gODUlIHNpbWlsYXJpdHkgdGhyZXNob2xkXG4gICAgXG4gICAgY29uc3QgcHJvb2Y6IEJpb21ldHJpY1Byb29mID0ge1xuICAgICAgaXNWZXJpZmllZCxcbiAgICAgIGNvbmZpZGVuY2VTY29yZTogc2ltaWxhcml0eSxcbiAgICAgIGJpb21ldHJpY0hhc2g6IGN1cnJlbnRIYXNoLFxuICAgICAgcHJvb2ZHZW5lcmF0ZWQ6IHRydWVcbiAgICB9O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgQmlvbWV0cmljIHZlcmlmaWNhdGlvbiBjb21wbGV0ZTonLCB7XG4gICAgICB2ZXJpZmllZDogaXNWZXJpZmllZCxcbiAgICAgIGNvbmZpZGVuY2U6IGAke01hdGgucm91bmQoc2ltaWxhcml0eSAqIDEwMCl9JWBcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcHJvb2Y7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gYmlvbWV0cmljIGhhc2hlc1xuICAgKiAoSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBiZSBpbiBhIFpLIGNpcmN1aXQpXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUhhc2hTaW1pbGFyaXR5KGhhc2gxOiBzdHJpbmcsIGhhc2gyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmIChoYXNoMSA9PT0gaGFzaDIpIHJldHVybiAxLjA7XG4gICAgXG4gICAgLy8gU2ltcGxlIHNpbWlsYXJpdHkgYmFzZWQgb24gaGFzaCBwcmVmaXggbWF0Y2hpbmdcbiAgICBsZXQgbWF0Y2hlcyA9IDA7XG4gICAgY29uc3QgY29tcGFyZUxlbmd0aCA9IE1hdGgubWluKGhhc2gxLmxlbmd0aCwgaGFzaDIubGVuZ3RoLCAxNik7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wYXJlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNoMVtpXSA9PT0gaGFzaDJbaV0pIG1hdGNoZXMrKztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG1hdGNoZXMgLyBjb21wYXJlTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIPCflJAgQU5PTllNT1VTIEZBQ0UgVkVSSUZJQ0FUSU9OXG4gICAqIFZlcmlmeSBmYWNlIGF1dGhlbnRpY2l0eSB3aXRob3V0IGlkZW50aXR5IGxpbmthZ2VcbiAgICovXG4gIGFzeW5jIHZlcmlmeUZhY2VBdXRoZW50aWNpdHkoZmFjZURhdGE6IEZhY2VEYXRhKTogUHJvbWlzZTx7XG4gICAgaXNSZWFsUGVyc29uOiBib29sZWFuO1xuICAgIGlzTGl2ZTogYm9vbGVhbjtcbiAgICBxdWFsaXR5U2NvcmU6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFZlcmlmeWluZyBmYWNlIGF1dGhlbnRpY2l0eS4uLicpO1xuICAgIFxuICAgIC8vIFNpbXVsYXRlIGxpdmVuZXNzIGRldGVjdGlvbiBhbmQgYW50aS1zcG9vZmluZ1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgXG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBjaGVjazpcbiAgICAvLyAtIEZhY2UgbGl2ZW5lc3MgKGV5ZSBibGlua3MsIGhlYWQgbW92ZW1lbnQpXG4gICAgLy8gLSBBbnRpLXNwb29maW5nICgzRCBmYWNlIGRldGVjdGlvbilcbiAgICAvLyAtIEltYWdlIHF1YWxpdHkgYXNzZXNzbWVudFxuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGlzUmVhbFBlcnNvbjogZmFjZURhdGEuY29uZmlkZW5jZSA+IDAuOCxcbiAgICAgIGlzTGl2ZTogZmFjZURhdGEuY29uZmlkZW5jZSA+IDAuOSxcbiAgICAgIHF1YWxpdHlTY29yZTogZmFjZURhdGEuY29uZmlkZW5jZVxuICAgIH07XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBBdXRoZW50aWNpdHkgdmVyaWZpY2F0aW9uOicsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmFjZVZlcmlmaWNhdGlvblNlcnZpY2UgPSBuZXcgRmFjZVZlcmlmaWNhdGlvblNlcnZpY2UoKTsiXSwibmFtZXMiOlsiRmFjZVZlcmlmaWNhdGlvblNlcnZpY2UiLCJzdGFydENhbWVyYSIsInZpZGVvRWxlbWVudCIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsInZpZGVvU3RyZWFtIiwiZ2V0VXNlck1lZGlhIiwidmlkZW8iLCJ3aWR0aCIsImlkZWFsIiwiaGVpZ2h0IiwiZmFjaW5nTW9kZSIsInNyY09iamVjdCIsImVycm9yIiwic3RvcENhbWVyYSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJjYXB0dXJlRmFjZSIsImNhbnZhcyIsImNvbnRleHQiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGFVcmwiLCJ0b0RhdGFVUkwiLCJjb25maWRlbmNlIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImdlbmVyYXRlQmlvbWV0cmljSGFzaCIsImZhY2VEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYnVmZmVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJoYXNoQnVmZmVyIiwiY3J5cHRvIiwic3VidGxlIiwiZGlnZXN0IiwiaGFzaEFycmF5IiwiQXJyYXkiLCJmcm9tIiwiVWludDhBcnJheSIsImhhc2hIZXgiLCJtYXAiLCJiIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJzdWJzdHJpbmciLCJ2ZXJpZnlGYWNlTWF0Y2giLCJjdXJyZW50RmFjZSIsInN0b3JlZEJpb21ldHJpY0hhc2giLCJjdXJyZW50SGFzaCIsInNpbWlsYXJpdHkiLCJjYWxjdWxhdGVIYXNoU2ltaWxhcml0eSIsImlzVmVyaWZpZWQiLCJwcm9vZiIsImNvbmZpZGVuY2VTY29yZSIsImJpb21ldHJpY0hhc2giLCJwcm9vZkdlbmVyYXRlZCIsInZlcmlmaWVkIiwiTWF0aCIsInJvdW5kIiwiaGFzaDEiLCJoYXNoMiIsIm1hdGNoZXMiLCJjb21wYXJlTGVuZ3RoIiwibWluIiwibGVuZ3RoIiwiaSIsInZlcmlmeUZhY2VBdXRoZW50aWNpdHkiLCJyZXN1bHQiLCJpc1JlYWxQZXJzb24iLCJpc0xpdmUiLCJxdWFsaXR5U2NvcmUiLCJjb25zdHJ1Y3RvciIsInN0cmVhbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJmYWNlVmVyaWZpY2F0aW9uU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/faceVerificationService.ts\n"));

/***/ })

}]);