"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_services_locationService_ts"],{

/***/ "(app-pages-browser)/./src/lib/services/locationService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/locationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocationService: function() { return /* binding */ LocationService; },\n/* harmony export */   locationService: function() { return /* binding */ locationService; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ LocationService,locationService auto */ // Browser-compatible crypto function\nconst createBrowserHash = async (data)=>{\n    if ( true && window.crypto && window.crypto.subtle) {\n        const encoder = new TextEncoder();\n        const dataBuffer = encoder.encode(data);\n        const hashBuffer = await window.crypto.subtle.digest(\"SHA-256\", dataBuffer);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        return hashArray.map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n        // Fallback for Node.js environments\n        const { createHash } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_next_dist_compiled_crypto-browserify_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"(app-pages-browser)/./node_modules/next/dist/compiled/crypto-browserify/index.js\", 23));\n        return createHash(\"sha256\").update(data).digest(\"hex\");\n    }\n};\n/**\n * ðŸ” PRIVATE LOCATION SERVICE\n * Handles location-based matching with zero-knowledge privacy\n */ class LocationService {\n    /**\n   * Get user's current location with permission\n   */ async getCurrentLocation() {\n        return new Promise((resolve, reject)=>{\n            if (!navigator.geolocation) {\n                reject(new Error(\"Geolocation is not supported by this browser\"));\n                return;\n            }\n            navigator.geolocation.getCurrentPosition((position)=>{\n                const location = {\n                    latitude: position.coords.latitude,\n                    longitude: position.coords.longitude,\n                    accuracy: position.coords.accuracy,\n                    timestamp: Date.now()\n                };\n                this.currentLocation = location;\n                console.log(\"\\uD83D\\uDCCD Location obtained:\", {\n                    lat: location.latitude.toFixed(6),\n                    lng: location.longitude.toFixed(6),\n                    accuracy: location.accuracy\n                });\n                resolve(location);\n            }, (error)=>{\n                console.error(\"âŒ Location error:\", error.message);\n                reject(new Error(\"Location access denied: \".concat(error.message)));\n            }, {\n                enableHighAccuracy: true,\n                timeout: 10000,\n                maximumAge: 300000 // 5 minutes cache\n            });\n        });\n    }\n    /**\n   * Create private location commitment (hash without revealing coordinates)\n   */ async createLocationCommitment(location) {\n        // Use coarse-grained location for privacy (rounded to ~1km precision)\n        const coarseLat = Math.round(location.latitude * 100) / 100;\n        const coarseLng = Math.round(location.longitude * 100) / 100;\n        const locationString = \"\".concat(coarseLat, \",\").concat(coarseLng);\n        return await createBrowserHash(locationString);\n    }\n    /**\n   * ðŸ”’ ZERO-KNOWLEDGE PROXIMITY MATCHING\n   * Proves two users are within range without revealing exact locations\n   */ async proveProximity(myLocation, targetLocationHash) {\n        let maxDistanceKm = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;\n        console.log(\"\\uD83D\\uDD10 Starting ZK proximity proof...\");\n        // In production, this would be a real ZK circuit\n        // For demo, we simulate the privacy-preserving calculation\n        const myLocationHash = await this.createLocationCommitment(myLocation);\n        // Simulate the ZK proof calculation\n        // In reality, this would use the target's location commitment\n        // and prove proximity without revealing either location\n        await new Promise((resolve)=>setTimeout(resolve, 1000)); // Simulate proof time\n        // For demo: determine if locations are \"close\" based on hash similarity\n        const proximity = this.simulatePrivateProximityCheck(myLocationHash, targetLocationHash);\n        return {\n            locationHash: myLocationHash,\n            proximityProof: proximity.isClose,\n            distance: proximity.isClose ? proximity.approximateDistance : undefined\n        };\n    }\n    /**\n   * Simulate private proximity checking (would be ZK circuit in production)\n   */ simulatePrivateProximityCheck(hash1, hash2) {\n        // Convert hashes to numeric values for proximity simulation\n        const num1 = parseInt(hash1.substring(0, 8), 16);\n        const num2 = parseInt(hash2.substring(0, 8), 16);\n        const hashDiff = Math.abs(num1 - num2);\n        const maxDiff = 0xFFFFFFFF * 0.1; // Within 10% hash space = \"close\"\n        const isClose = hashDiff < maxDiff;\n        const approximateDistance = isClose ? Math.round(hashDiff / maxDiff * 50) : undefined;\n        console.log(\"\\uD83E\\uDDEE ZK Proximity Calculation:\", {\n            isClose,\n            approximateDistance: approximateDistance ? \"~\".concat(approximateDistance, \"km\") : \"Too far\"\n        });\n        return {\n            isClose,\n            approximateDistance\n        };\n    }\n    /**\n   * Get location display string without revealing exact coordinates\n   */ getPrivacyFriendlyLocation(location) {\n        // Show only city-level precision\n        const lat = Math.round(location.latitude * 10) / 10;\n        const lng = Math.round(location.longitude * 10) / 10;\n        return \"~\".concat(lat, \", \").concat(lng);\n    }\n    constructor(){\n        this.currentLocation = null;\n    }\n}\nconst locationService = new LocationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvbG9jYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O3FGQUVBLHFDQUFxQztBQUNyQyxNQUFNQSxvQkFBb0IsT0FBT0M7SUFDL0IsSUFBSSxLQUFrQixJQUFlQyxPQUFPQyxNQUFNLElBQUlELE9BQU9DLE1BQU0sQ0FBQ0MsTUFBTSxFQUFFO1FBQzFFLE1BQU1DLFVBQVUsSUFBSUM7UUFDcEIsTUFBTUMsYUFBYUYsUUFBUUcsTUFBTSxDQUFDUDtRQUNsQyxNQUFNUSxhQUFhLE1BQU1QLE9BQU9DLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDTSxNQUFNLENBQUMsV0FBV0g7UUFDaEUsTUFBTUksWUFBWUMsTUFBTUMsSUFBSSxDQUFDLElBQUlDLFdBQVdMO1FBQzVDLE9BQU9FLFVBQVVJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztJQUNsRSxPQUFPO1FBQ0wsb0NBQW9DO1FBQ3BDLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUcsTUFBTSxrUkFBTztRQUNwQyxPQUFPQSxXQUFXLFVBQVVDLE1BQU0sQ0FBQ3BCLE1BQU1TLE1BQU0sQ0FBQztJQUNsRDtBQUNGO0FBZUE7OztDQUdDLEdBQ00sTUFBTVk7SUFHWDs7R0FFQyxHQUNELE1BQU1DLHFCQUE0QztRQUNoRCxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsSUFBSSxDQUFDQyxVQUFVQyxXQUFXLEVBQUU7Z0JBQzFCRixPQUFPLElBQUlHLE1BQU07Z0JBQ2pCO1lBQ0Y7WUFFQUYsVUFBVUMsV0FBVyxDQUFDRSxrQkFBa0IsQ0FDdEMsQ0FBQ0M7Z0JBQ0MsTUFBTUMsV0FBeUI7b0JBQzdCQyxVQUFVRixTQUFTRyxNQUFNLENBQUNELFFBQVE7b0JBQ2xDRSxXQUFXSixTQUFTRyxNQUFNLENBQUNDLFNBQVM7b0JBQ3BDQyxVQUFVTCxTQUFT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LE1BQU15QyxrQkFBa0IsSUFBSTNELGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3NlcnZpY2VzL2xvY2F0aW9uU2VydmljZS50cz82NzliIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyBCcm93c2VyLWNvbXBhdGlibGUgY3J5cHRvIGZ1bmN0aW9uXG5jb25zdCBjcmVhdGVCcm93c2VySGFzaCA9IGFzeW5jIChkYXRhOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLnN1YnRsZSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBkYXRhQnVmZmVyID0gZW5jb2Rlci5lbmNvZGUoZGF0YSk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGFCdWZmZXIpO1xuICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuICAgIHJldHVybiBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgZm9yIE5vZGUuanMgZW52aXJvbm1lbnRzXG4gICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBhd2FpdCBpbXBvcnQoJ2NyeXB0bycpO1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KCdoZXgnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBMb2NhdGlvbkRhdGEge1xuICBsYXRpdHVkZTogbnVtYmVyO1xuICBsb25naXR1ZGU6IG51bWJlcjtcbiAgYWNjdXJhY3k/OiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByaXZhdGVMb2NhdGlvblByb29mIHtcbiAgbG9jYXRpb25IYXNoOiBzdHJpbmc7XG4gIHByb3hpbWl0eVByb29mOiBib29sZWFuO1xuICBkaXN0YW5jZT86IG51bWJlcjsgLy8gT25seSByZXZlYWxlZCBpZiBjbG9zZVxufVxuXG4vKipcbiAqIPCflJAgUFJJVkFURSBMT0NBVElPTiBTRVJWSUNFXG4gKiBIYW5kbGVzIGxvY2F0aW9uLWJhc2VkIG1hdGNoaW5nIHdpdGggemVyby1rbm93bGVkZ2UgcHJpdmFjeVxuICovXG5leHBvcnQgY2xhc3MgTG9jYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uRGF0YSB8IG51bGwgPSBudWxsO1xuICBcbiAgLyoqXG4gICAqIEdldCB1c2VyJ3MgY3VycmVudCBsb2NhdGlvbiB3aXRoIHBlcm1pc3Npb25cbiAgICovXG4gIGFzeW5jIGdldEN1cnJlbnRMb2NhdGlvbigpOiBQcm9taXNlPExvY2F0aW9uRGF0YT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdHZW9sb2NhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlcicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxuICAgICAgICAocG9zaXRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBsb2NhdGlvbjogTG9jYXRpb25EYXRhID0ge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgIGFjY3VyYWN5OiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3ksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk40gTG9jYXRpb24gb2J0YWluZWQ6Jywge1xuICAgICAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXRpdHVkZS50b0ZpeGVkKDYpLFxuICAgICAgICAgICAgbG5nOiBsb2NhdGlvbi5sb25naXR1ZGUudG9GaXhlZCg2KSxcbiAgICAgICAgICAgIGFjY3VyYWN5OiBsb2NhdGlvbi5hY2N1cmFjeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHJlc29sdmUobG9jYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTG9jYXRpb24gZXJyb3I6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTG9jYXRpb24gYWNjZXNzIGRlbmllZDogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcbiAgICAgICAgICB0aW1lb3V0OiAxMDAwMCxcbiAgICAgICAgICBtYXhpbXVtQWdlOiAzMDAwMDAgLy8gNSBtaW51dGVzIGNhY2hlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHByaXZhdGUgbG9jYXRpb24gY29tbWl0bWVudCAoaGFzaCB3aXRob3V0IHJldmVhbGluZyBjb29yZGluYXRlcylcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUxvY2F0aW9uQ29tbWl0bWVudChsb2NhdGlvbjogTG9jYXRpb25EYXRhKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBVc2UgY29hcnNlLWdyYWluZWQgbG9jYXRpb24gZm9yIHByaXZhY3kgKHJvdW5kZWQgdG8gfjFrbSBwcmVjaXNpb24pXG4gICAgY29uc3QgY29hcnNlTGF0ID0gTWF0aC5yb3VuZChsb2NhdGlvbi5sYXRpdHVkZSAqIDEwMCkgLyAxMDA7XG4gICAgY29uc3QgY29hcnNlTG5nID0gTWF0aC5yb3VuZChsb2NhdGlvbi5sb25naXR1ZGUgKiAxMDApIC8gMTAwO1xuICAgIFxuICAgIGNvbnN0IGxvY2F0aW9uU3RyaW5nID0gYCR7Y29hcnNlTGF0fSwke2NvYXJzZUxuZ31gO1xuICAgIHJldHVybiBhd2FpdCBjcmVhdGVCcm93c2VySGFzaChsb2NhdGlvblN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICog8J+UkiBaRVJPLUtOT1dMRURHRSBQUk9YSU1JVFkgTUFUQ0hJTkdcbiAgICogUHJvdmVzIHR3byB1c2VycyBhcmUgd2l0aGluIHJhbmdlIHdpdGhvdXQgcmV2ZWFsaW5nIGV4YWN0IGxvY2F0aW9uc1xuICAgKi9cbiAgYXN5bmMgcHJvdmVQcm94aW1pdHkoXG4gICAgbXlMb2NhdGlvbjogTG9jYXRpb25EYXRhLFxuICAgIHRhcmdldExvY2F0aW9uSGFzaDogc3RyaW5nLFxuICAgIG1heERpc3RhbmNlS206IG51bWJlciA9IDUwXG4gICk6IFByb21pc2U8UHJpdmF0ZUxvY2F0aW9uUHJvb2Y+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UkCBTdGFydGluZyBaSyBwcm94aW1pdHkgcHJvb2YuLi4nKTtcbiAgICBcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGJlIGEgcmVhbCBaSyBjaXJjdWl0XG4gICAgLy8gRm9yIGRlbW8sIHdlIHNpbXVsYXRlIHRoZSBwcml2YWN5LXByZXNlcnZpbmcgY2FsY3VsYXRpb25cbiAgICBcbiAgICBjb25zdCBteUxvY2F0aW9uSGFzaCA9IGF3YWl0IHRoaXMuY3JlYXRlTG9jYXRpb25Db21taXRtZW50KG15TG9jYXRpb24pO1xuICAgIFxuICAgIC8vIFNpbXVsYXRlIHRoZSBaSyBwcm9vZiBjYWxjdWxhdGlvblxuICAgIC8vIEluIHJlYWxpdHksIHRoaXMgd291bGQgdXNlIHRoZSB0YXJnZXQncyBsb2NhdGlvbiBjb21taXRtZW50XG4gICAgLy8gYW5kIHByb3ZlIHByb3hpbWl0eSB3aXRob3V0IHJldmVhbGluZyBlaXRoZXIgbG9jYXRpb25cbiAgICBcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpOyAvLyBTaW11bGF0ZSBwcm9vZiB0aW1lXG4gICAgXG4gICAgLy8gRm9yIGRlbW86IGRldGVybWluZSBpZiBsb2NhdGlvbnMgYXJlIFwiY2xvc2VcIiBiYXNlZCBvbiBoYXNoIHNpbWlsYXJpdHlcbiAgICBjb25zdCBwcm94aW1pdHkgPSB0aGlzLnNpbXVsYXRlUHJpdmF0ZVByb3hpbWl0eUNoZWNrKG15TG9jYXRpb25IYXNoLCB0YXJnZXRMb2NhdGlvbkhhc2gpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbkhhc2g6IG15TG9jYXRpb25IYXNoLFxuICAgICAgcHJveGltaXR5UHJvb2Y6IHByb3hpbWl0eS5pc0Nsb3NlLFxuICAgICAgZGlzdGFuY2U6IHByb3hpbWl0eS5pc0Nsb3NlID8gcHJveGltaXR5LmFwcHJveGltYXRlRGlzdGFuY2UgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIHByaXZhdGUgcHJveGltaXR5IGNoZWNraW5nICh3b3VsZCBiZSBaSyBjaXJjdWl0IGluIHByb2R1Y3Rpb24pXG4gICAqL1xuICBwcml2YXRlIHNpbXVsYXRlUHJpdmF0ZVByb3hpbWl0eUNoZWNrKGhhc2gxOiBzdHJpbmcsIGhhc2gyOiBzdHJpbmcpOiB7XG4gICAgaXNDbG9zZTogYm9vbGVhbjtcbiAgICBhcHByb3hpbWF0ZURpc3RhbmNlPzogbnVtYmVyO1xuICB9IHtcbiAgICAvLyBDb252ZXJ0IGhhc2hlcyB0byBudW1lcmljIHZhbHVlcyBmb3IgcHJveGltaXR5IHNpbXVsYXRpb25cbiAgICBjb25zdCBudW0xID0gcGFyc2VJbnQoaGFzaDEuc3Vic3RyaW5nKDAsIDgpLCAxNik7XG4gICAgY29uc3QgbnVtMiA9IHBhcnNlSW50KGhhc2gyLnN1YnN0cmluZygwLCA4KSwgMTYpO1xuICAgIFxuICAgIGNvbnN0IGhhc2hEaWZmID0gTWF0aC5hYnMobnVtMSAtIG51bTIpO1xuICAgIGNvbnN0IG1heERpZmYgPSAweEZGRkZGRkZGICogMC4xOyAvLyBXaXRoaW4gMTAlIGhhc2ggc3BhY2UgPSBcImNsb3NlXCJcbiAgICBcbiAgICBjb25zdCBpc0Nsb3NlID0gaGFzaERpZmYgPCBtYXhEaWZmO1xuICAgIGNvbnN0IGFwcHJveGltYXRlRGlzdGFuY2UgPSBpc0Nsb3NlID8gTWF0aC5yb3VuZCgoaGFzaERpZmYgLyBtYXhEaWZmKSAqIDUwKSA6IHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+nriBaSyBQcm94aW1pdHkgQ2FsY3VsYXRpb246Jywge1xuICAgICAgaXNDbG9zZSxcbiAgICAgIGFwcHJveGltYXRlRGlzdGFuY2U6IGFwcHJveGltYXRlRGlzdGFuY2UgPyBgfiR7YXBwcm94aW1hdGVEaXN0YW5jZX1rbWAgOiAnVG9vIGZhcidcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyBpc0Nsb3NlLCBhcHByb3hpbWF0ZURpc3RhbmNlIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvY2F0aW9uIGRpc3BsYXkgc3RyaW5nIHdpdGhvdXQgcmV2ZWFsaW5nIGV4YWN0IGNvb3JkaW5hdGVzXG4gICAqL1xuICBnZXRQcml2YWN5RnJpZW5kbHlMb2NhdGlvbihsb2NhdGlvbjogTG9jYXRpb25EYXRhKTogc3RyaW5nIHtcbiAgICAvLyBTaG93IG9ubHkgY2l0eS1sZXZlbCBwcmVjaXNpb25cbiAgICBjb25zdCBsYXQgPSBNYXRoLnJvdW5kKGxvY2F0aW9uLmxhdGl0dWRlICogMTApIC8gMTA7XG4gICAgY29uc3QgbG5nID0gTWF0aC5yb3VuZChsb2NhdGlvbi5sb25naXR1ZGUgKiAxMCkgLyAxMDtcbiAgICByZXR1cm4gYH4ke2xhdH0sICR7bG5nfWA7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxvY2F0aW9uU2VydmljZSA9IG5ldyBMb2NhdGlvblNlcnZpY2UoKTsiXSwibmFtZXMiOlsiY3JlYXRlQnJvd3Nlckhhc2giLCJkYXRhIiwid2luZG93IiwiY3J5cHRvIiwic3VidGxlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGF0YUJ1ZmZlciIsImVuY29kZSIsImhhc2hCdWZmZXIiLCJkaWdlc3QiLCJoYXNoQXJyYXkiLCJBcnJheSIsImZyb20iLCJVaW50OEFycmF5IiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsIkxvY2F0aW9uU2VydmljZSIsImdldEN1cnJlbnRMb2NhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibmF2aWdhdG9yIiwiZ2VvbG9jYXRpb24iLCJFcnJvciIsImdldEN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwibG9jYXRpb24iLCJsYXRpdHVkZSIsImNvb3JkcyIsImxvbmdpdHVkZSIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImN1cnJlbnRMb2NhdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJsYXQiLCJ0b0ZpeGVkIiwibG5nIiwiZXJyb3IiLCJtZXNzYWdlIiwiZW5hYmxlSGlnaEFjY3VyYWN5IiwidGltZW91dCIsIm1heGltdW1BZ2UiLCJjcmVhdGVMb2NhdGlvbkNvbW1pdG1lbnQiLCJjb2Fyc2VMYXQiLCJNYXRoIiwicm91bmQiLCJjb2Fyc2VMbmciLCJsb2NhdGlvblN0cmluZyIsInByb3ZlUHJveGltaXR5IiwibXlMb2NhdGlvbiIsInRhcmdldExvY2F0aW9uSGFzaCIsIm1heERpc3RhbmNlS20iLCJteUxvY2F0aW9uSGFzaCIsInNldFRpbWVvdXQiLCJwcm94aW1pdHkiLCJzaW11bGF0ZVByaXZhdGVQcm94aW1pdHlDaGVjayIsImxvY2F0aW9uSGFzaCIsInByb3hpbWl0eVByb29mIiwiaXNDbG9zZSIsImRpc3RhbmNlIiwiYXBwcm94aW1hdGVEaXN0YW5jZSIsInVuZGVmaW5lZCIsImhhc2gxIiwiaGFzaDIiLCJudW0xIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJudW0yIiwiaGFzaERpZmYiLCJhYnMiLCJtYXhEaWZmIiwiZ2V0UHJpdmFjeUZyaWVuZGx5TG9jYXRpb24iLCJsb2NhdGlvblNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/locationService.ts\n"));

/***/ })

}]);